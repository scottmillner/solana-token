use serde::{Deserialize, Serialize};
use std::fs;

#[derive(Debug, Deserialize, Serialize)]
struct Idl {
    instructions: Vec<Instruction>,
    accounts: Vec<AccountType>,
    types: Vec<TypeDef>,
}

#[derive(Debug, Deserialize, Serialize)]
struct Instruction {
    name: String,
    discriminator: Vec<u8>,
    accounts: Vec<Account>,
    args: Vec<Arg>,
}

#[derive(Debug, Deserialize, Serialize)]
struct Account {
    name: String,
    #[serde(default)]
    writable: bool,
    #[serde(default)]
    signer: bool,
}

#[derive(Debug, Deserialize, Serialize)]
struct Arg {
    name: String,
    #[serde(rename = "type")]
    type_: String,
}

#[derive(Debug, Deserialize, Serialize)]
struct AccountType {
    name: String,
    discriminator: Vec<u8>,
}

#[derive(Debug, Deserialize, Serialize)]
struct TypeDef {
    name: String,
}

fn main() {
    let idl_path = "../target/idl/solana_token.json";
    let out_path = "src/generated.rs";

    // Tell cargo to rerun if the IDL changes
    println!("cargo:rerun-if-changed={}", idl_path);

    // Read and parse IDL
    let idl_content = fs::read_to_string(idl_path)
        .expect("Failed to read IDL file. Run 'anchor build' first.");
    let idl: Idl = serde_json::from_str(&idl_content)
        .expect("Failed to parse IDL JSON");

    // Generate Rust code
    let mut output = String::new();
    output.push_str("// Auto-generated from IDL - DO NOT EDIT\n");
    output.push_str("// Generated by build.rs from target/idl/solana_token.json\n\n");
    output.push_str("#![allow(dead_code)]\n\n");
    output.push_str("use anchor_lang::{AnchorSerialize, Discriminator, InstructionData, ToAccountMetas};\n");
    output.push_str("use anchor_client::solana_sdk::{instruction::AccountMeta, pubkey::Pubkey};\n\n");

    // Generate code for each instruction
    for instruction in &idl.instructions {
        generate_instruction(&mut output, instruction);
    }

    // Write generated code
    fs::write(out_path, output)
        .expect("Failed to write generated.rs");

    println!("cargo:warning=Generated {} instructions from IDL", idl.instructions.len());
}

fn generate_instruction(output: &mut String, instruction: &Instruction) {
    let module_name = to_snake_case(&instruction.name);
    let struct_name = to_pascal_case(&instruction.name);

    output.push_str(&format!("pub mod {} {{\n", module_name));
    output.push_str("    use super::*;\n\n");

    // Generate instruction args struct
    output.push_str("    #[derive(AnchorSerialize)]\n");
    output.push_str(&format!("    pub struct {} {{\n", struct_name));
    for arg in &instruction.args {
        let rust_type = map_idl_type(&arg.type_);
        output.push_str(&format!("        pub {}: {},\n", arg.name, rust_type));
    }
    output.push_str("    }\n\n");

    // Generate Discriminator impl
    output.push_str(&format!("    impl Discriminator for {} {{\n", struct_name));
    let disc_bytes = instruction.discriminator.iter()
        .map(|b| b.to_string())
        .collect::<Vec<_>>()
        .join(", ");
    output.push_str(&format!("        const DISCRIMINATOR: &'static [u8] = &[{}];\n", disc_bytes));
    output.push_str("    }\n\n");

    // Generate InstructionData impl
    output.push_str(&format!("    impl InstructionData for {} {{}}\n\n", struct_name));

    // Generate Accounts struct
    output.push_str("    pub struct Accounts {\n");
    for account in &instruction.accounts {
        output.push_str(&format!("        pub {}: Pubkey,\n", account.name));
    }
    output.push_str("    }\n\n");

    // Generate ToAccountMetas impl
    output.push_str("    impl ToAccountMetas for Accounts {\n");
    output.push_str("        fn to_account_metas(&self, _is_signer: Option<bool>) -> Vec<AccountMeta> {\n");
    output.push_str("            vec![\n");
    for account in &instruction.accounts {
        let writable = account.writable;
        let signer = account.signer;
        if writable {
            output.push_str(&format!("                AccountMeta::new(self.{}, {}),\n",
                account.name, signer));
        } else {
            output.push_str(&format!("                AccountMeta::new_readonly(self.{}, {}),\n",
                account.name, signer));
        }
    }
    output.push_str("            ]\n");
    output.push_str("        }\n");
    output.push_str("    }\n");

    output.push_str("}\n\n");
}

fn to_snake_case(s: &str) -> String {
    let mut result = String::new();
    for (i, ch) in s.chars().enumerate() {
        if ch.is_uppercase() {
            if i > 0 {
                result.push('_');
            }
            result.push(ch.to_ascii_lowercase());
        } else {
            result.push(ch);
        }
    }
    result
}

fn to_pascal_case(s: &str) -> String {
    s.split('_')
        .map(|word| {
            let mut chars = word.chars();
            match chars.next() {
                None => String::new(),
                Some(first) => first.to_uppercase().chain(chars).collect(),
            }
        })
        .collect()
}

fn map_idl_type(idl_type: &str) -> &str {
    match idl_type {
        "u8" => "u8",
        "u16" => "u16",
        "u32" => "u32",
        "u64" => "u64",
        "u128" => "u128",
        "i8" => "i8",
        "i16" => "i16",
        "i32" => "i32",
        "i64" => "i64",
        "i128" => "i128",
        "bool" => "bool",
        "string" => "String",
        "pubkey" => "Pubkey",
        _ => idl_type, // Pass through for custom types
    }
}
