// Code generation module - used by build.rs and testable
use serde::{Deserialize, Serialize};

#[derive(Debug, Deserialize, Serialize)]
pub struct Idl {
    pub instructions: Vec<Instruction>,
    pub accounts: Vec<AccountType>,
    pub types: Vec<TypeDef>,
}

#[derive(Debug, Deserialize, Serialize)]
pub struct Instruction {
    pub name: String,
    pub discriminator: Vec<u8>,
    pub accounts: Vec<Account>,
    pub args: Vec<Arg>,
}

#[derive(Debug, Deserialize, Serialize)]
pub struct Account {
    pub name: String,
    #[serde(default)]
    pub writable: bool,
    #[serde(default)]
    pub signer: bool,
}

#[derive(Debug, Deserialize, Serialize)]
pub struct Arg {
    pub name: String,
    #[serde(rename = "type")]
    pub type_: String,
}

#[derive(Debug, Deserialize, Serialize)]
pub struct AccountType {
    pub name: String,
    pub discriminator: Vec<u8>,
}

#[derive(Debug, Deserialize, Serialize)]
pub struct TypeDef {
    pub name: String,
}

pub fn generate_code(idl: &Idl) -> String {
    let mut output = String::new();
    output.push_str("// Auto-generated from IDL - DO NOT EDIT\n");
    output.push_str("// Generated by build.rs from target/idl/solana_token.json\n\n");
    output.push_str("#![allow(dead_code)]\n\n");
    output.push_str("use anchor_lang::{AnchorSerialize, Discriminator, InstructionData, ToAccountMetas};\n");
    output.push_str("use anchor_client::solana_sdk::{instruction::AccountMeta, pubkey::Pubkey};\n\n");

    // Generate code for each instruction
    for instruction in &idl.instructions {
        generate_instruction(&mut output, instruction);
    }

    output
}

pub fn generate_instruction(output: &mut String, instruction: &Instruction) {
    let module_name = to_snake_case(&instruction.name);
    let struct_name = to_pascal_case(&instruction.name);

    output.push_str(&format!("pub mod {} {{\n", module_name));
    output.push_str("    use super::*;\n\n");

    // Generate instruction args struct
    output.push_str("    #[derive(AnchorSerialize)]\n");
    output.push_str(&format!("    pub struct {} {{\n", struct_name));
    for arg in &instruction.args {
        let rust_type = map_idl_type(&arg.type_);
        output.push_str(&format!("        pub {}: {},\n", arg.name, rust_type));
    }
    output.push_str("    }\n\n");

    // Generate Discriminator impl
    output.push_str(&format!("    impl Discriminator for {} {{\n", struct_name));
    let disc_bytes = instruction.discriminator.iter()
        .map(|b| b.to_string())
        .collect::<Vec<_>>()
        .join(", ");
    output.push_str(&format!("        const DISCRIMINATOR: &'static [u8] = &[{}];\n", disc_bytes));
    output.push_str("    }\n\n");

    // Generate InstructionData impl
    output.push_str(&format!("    impl InstructionData for {} {{}}\n\n", struct_name));

    // Generate Accounts struct
    output.push_str("    pub struct Accounts {\n");
    for account in &instruction.accounts {
        output.push_str(&format!("        pub {}: Pubkey,\n", account.name));
    }
    output.push_str("    }\n\n");

    // Generate ToAccountMetas impl
    output.push_str("    impl ToAccountMetas for Accounts {\n");
    output.push_str("        fn to_account_metas(&self, _is_signer: Option<bool>) -> Vec<AccountMeta> {\n");
    output.push_str("            vec![\n");
    for account in &instruction.accounts {
        let writable = account.writable;
        let signer = account.signer;
        if writable {
            output.push_str(&format!("                AccountMeta::new(self.{}, {}),\n",
                account.name, signer));
        } else {
            output.push_str(&format!("                AccountMeta::new_readonly(self.{}, {}),\n",
                account.name, signer));
        }
    }
    output.push_str("            ]\n");
    output.push_str("        }\n");
    output.push_str("    }\n");

    output.push_str("}\n\n");
}

pub fn to_snake_case(s: &str) -> String {
    let mut result = String::new();
    for (i, ch) in s.chars().enumerate() {
        if ch.is_uppercase() {
            if i > 0 {
                result.push('_');
            }
            result.push(ch.to_ascii_lowercase());
        } else {
            result.push(ch);
        }
    }
    result
}

pub fn to_pascal_case(s: &str) -> String {
    s.split('_')
        .map(|word| {
            let mut chars = word.chars();
            match chars.next() {
                None => String::new(),
                Some(first) => first.to_uppercase().chain(chars).collect(),
            }
        })
        .collect()
}

pub fn map_idl_type(idl_type: &str) -> &str {
    match idl_type {
        "u8" => "u8",
        "u16" => "u16",
        "u32" => "u32",
        "u64" => "u64",
        "u128" => "u128",
        "i8" => "i8",
        "i16" => "i16",
        "i32" => "i32",
        "i64" => "i64",
        "i128" => "i128",
        "bool" => "bool",
        "string" => "String",
        "pubkey" => "Pubkey",
        _ => idl_type, // Pass through for custom types
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_to_snake_case() {
        assert_eq!(to_snake_case("initialize"), "initialize");
        assert_eq!(to_snake_case("mintTokens"), "mint_tokens");
        assert_eq!(to_snake_case("createTokenAccount"), "create_token_account");
        assert_eq!(to_snake_case("MintTokens"), "mint_tokens");
    }

    #[test]
    fn test_to_pascal_case() {
        assert_eq!(to_pascal_case("initialize"), "Initialize");
        assert_eq!(to_pascal_case("mint_tokens"), "MintTokens");
        assert_eq!(to_pascal_case("create_token_account"), "CreateTokenAccount");
    }

    #[test]
    fn test_map_idl_type() {
        assert_eq!(map_idl_type("u8"), "u8");
        assert_eq!(map_idl_type("u64"), "u64");
        assert_eq!(map_idl_type("bool"), "bool");
        assert_eq!(map_idl_type("string"), "String");
        assert_eq!(map_idl_type("pubkey"), "Pubkey");
        assert_eq!(map_idl_type("CustomType"), "CustomType");
    }

    #[test]
    fn test_idl_parsing() {
        let idl_json = r#"{
            "instructions": [
                {
                    "name": "initialize",
                    "discriminator": [175, 175, 109, 31, 13, 152, 155, 237],
                    "accounts": [
                        {"name": "mint", "writable": true, "signer": true},
                        {"name": "authority", "writable": true, "signer": true}
                    ],
                    "args": [
                        {"name": "decimals", "type": "u8"}
                    ]
                }
            ],
            "accounts": [],
            "types": []
        }"#;

        let idl: Idl = serde_json::from_str(idl_json).expect("Failed to parse test IDL");

        assert_eq!(idl.instructions.len(), 1);
        assert_eq!(idl.instructions[0].name, "initialize");
        assert_eq!(idl.instructions[0].discriminator.len(), 8);
        assert_eq!(idl.instructions[0].accounts.len(), 2);
        assert_eq!(idl.instructions[0].args.len(), 1);
        assert_eq!(idl.instructions[0].args[0].name, "decimals");
        assert_eq!(idl.instructions[0].args[0].type_, "u8");
    }

    #[test]
    fn test_instruction_code_generation() {
        let instruction = Instruction {
            name: "test_instruction".to_string(),
            discriminator: vec![1, 2, 3, 4, 5, 6, 7, 8],
            accounts: vec![
                Account {
                    name: "account1".to_string(),
                    writable: true,
                    signer: false,
                },
                Account {
                    name: "account2".to_string(),
                    writable: false,
                    signer: true,
                },
            ],
            args: vec![
                Arg {
                    name: "amount".to_string(),
                    type_: "u64".to_string(),
                },
            ],
        };

        let mut output = String::new();
        generate_instruction(&mut output, &instruction);

        // Verify generated code contains expected elements
        assert!(output.contains("pub mod test_instruction"));
        assert!(output.contains("pub struct TestInstruction"));
        assert!(output.contains("pub amount: u64"));
        assert!(output.contains("const DISCRIMINATOR"));
        assert!(output.contains("[1, 2, 3, 4, 5, 6, 7, 8]"));
        assert!(output.contains("impl InstructionData for TestInstruction"));
        assert!(output.contains("pub struct Accounts"));
        assert!(output.contains("pub account1: Pubkey"));
        assert!(output.contains("pub account2: Pubkey"));
        assert!(output.contains("AccountMeta::new(self.account1, false)"));
        assert!(output.contains("AccountMeta::new_readonly(self.account2, true)"));
    }
}
